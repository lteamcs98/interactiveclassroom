<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<link rel="stylesheet" href="http://www.cs.dartmouth.edu/~cs1/azul.css" type="text/css" />


<div id = "menubar">
<ul>
<li><a href="http://www.cs.dartmouth.edu/~cs1/syllabus.html">Syllabus</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/schedule.html">Schedule</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/shortassign/short_assignments.html">Short assignments</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/labs/lab_assignments.html">Labs</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/exams.html">Exams</a>
<li><a href="http://www.cs.dartmouth.edu/~cs1/software.html">Course software</a>
<li> <a href="http://greenteapress.com/thinkpython/thinkpython.html">Book</a>
<li><A HREF="&#109;&#97;&#105;&#108;&#116;&#111;&#58;%63%73%31%68%65%6C%70%40%63%73%2E%64%61%72%74%6D%6F%75%74%68%2E%65%64%75">Get help</A>
</ul>
</div>

<div id = "termtitle"> CS 1:  Winter 2012 </div> 
<h1 id="lab-assignment-3">Lab Assignment 3</h1>
<p><a href="../../labs/quicksort/lab_quicksort.html">Lab Assignment 3</a> is now posted, and it's due next Monday, February 20.</p>
<h1 id="short-assignment-10">Short Assignment 10</h1>
<p><a href="../../shortassign/file/sa_file.html">Short Assignment 10</a> is posted and due on Wednesday.</p>
<h1 id="merge-sort-continued">Merge sort, continued</h1>
<p>Last time, we saw the idea of linear-time merging, but we have not yet seen the code. We also briefly saw the code for merge sort, but we'll take a look at it again.</p>
<h3 id="linear-time-merging">Linear-time merging</h3>
<p>Recall the idea of linear-time merging: we have two sorted sublists, and we want to merge them together into a single sorted sublist. We repeatedly take the smallest untaken item from each of the two lists and copy it into the output list. Eventually, we have taken all the items from one of the two lists, and at that point, we can just copy all the remaining items in the other list into the output list.</p>
<p>Look at the <code>merge</code> function in <a href="merge_sort.py">merge_sort.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># merge_sort.py</span><br /><span class="co"># Merge sort example for cs1</span><br /><span class="co"># Devin Balkcom</span><br /><span class="co"># October, 2011</span><br /><span class="co"># Modified by THC.</span><br /><br /><span class="co"># Take two sorted lists, the_list[p : q+1] and the_list[q+1 : r+1],</span><br /><span class="co"># and merge them into the_list[p : r+1].</span><br /><span class="kw">def</span> merge(the_list, p, q, r):<br />    <span class="co"># Make a copy of the list items.</span><br />    left = the_list[p : q<span class="dv">+1</span>]<br />    right = the_list[q<span class="dv">+1</span> : r<span class="dv">+1</span>]<br /><br />    <span class="co"># Until we've gone through one of left and right, move</span><br />    <span class="co"># the smallest unmerged item into the next position in</span><br />    <span class="co"># the_list[p : r+1].</span><br /><br />    i = <span class="dv">0</span>       <span class="co"># index into left</span><br />    j = <span class="dv">0</span>       <span class="co"># index into right</span><br />    k = p       <span class="co"># index into the_list[p : r+1]</span><br /><br />    <span class="kw">while</span> i &lt; <span class="dt">len</span>(left) and j &lt; <span class="dt">len</span>(right):<br />        <span class="kw">if</span> left[i] &lt; right[j]:<br />            the_list[k] = left[i]<br />            i += <span class="dv">1</span><br />        <span class="kw">else</span>:<br />            the_list[k] = right[j]<br />            j += <span class="dv">1</span><br />        k += <span class="dv">1</span><br /><br />    <span class="co"># We've gone through one of left and right entirely.</span><br />    <span class="co"># Copy the remainder of the other to the end of the_list[p : r+1].</span><br /><br />    <span class="co"># If left has remaining items, copy them into the_list, using list slices.</span><br />    <span class="kw">if</span> i &lt; <span class="dt">len</span>(left):<br />        the_list[k : r<span class="dv">+1</span>] = left[i:]<br /><br />    <span class="co"># If right has remaining items, copy them into the_list, using list slices.</span><br />    <span class="kw">if</span> j &lt; <span class="dt">len</span>(right):<br />        the_list[k : r<span class="dv">+1</span>] = right[j:]<br /><br /><span class="co"># Sort the_list[p : r+1], using merge sort.</span><br /><span class="kw">def</span> merge_sort(the_list, p = <span class="ot">None</span>, r = <span class="ot">None</span>):<br />    <span class="co"># If using the default parameters, sort the entire list.</span><br />    <span class="kw">if</span> p == <span class="ot">None</span> and r == <span class="ot">None</span>:<br />        p = <span class="dv">0</span><br />        r = <span class="dt">len</span>(the_list) - <span class="dv">1</span><br /><br />    <span class="kw">if</span> p &lt; r:   <span class="co"># nothing to do if the sublist has fewer than 2 items</span><br />        q = (p + r) / <span class="dv">2</span>                 <span class="co"># midpoint of p and r</span><br />        merge_sort(the_list, p, q)      <span class="co"># recursively sort the_list[p : q+1]</span><br />        merge_sort(the_list, q<span class="dv">+1</span>, r)    <span class="co"># recursively sort the_list[q+1 : r+1]</span><br />        merge(the_list, p, q, r)        <span class="co"># and merge them together</span><br /><br />l = [<span class="dv">19</span>, <span class="dv">18</span>, <span class="dv">24</span>, <span class="dv">72</span>, <span class="dv">16</span>, <span class="dv">49</span>, <span class="dv">13</span>, <span class="dv">12</span>, <span class="dv">1</span>, <span class="dv">66</span>]<br />merge_sort(l)<br /><span class="kw">print</span> l</code></pre>
<p>Notice that we can copy part of one list into another using <strong>slice notation</strong>, that is the colon within the square brackets. So this line:</p>
<pre class="sourceCode"><code class="sourceCode python">the_list[k : r<span class="dv">+1</span>] = left[i:]</code></pre>
<p>copies the items in <code>left</code> starting at <code>i</code> into <code>the_list</code>, starting at index <code>k</code>.</p>
<p>The merge function merges the sorted sublists <code>the_list[p : q+1]</code> (containing the items from index <code>p</code> through index <code>q</code>—remember that with slice notation, the index after the colon is 1 greater than the index of the last item in the sublist) and and <code>the_list[q+1 : r+1]</code> (containing the items from index <code>q+1</code> through index <code>r</code>) into the sorted sublist <code>the_list[p : r+1]</code>. Notice that here the lists being merged are actually two consecutive sublists of <code>the_list</code>, and that they are being merged into the same locations, indices <code>p</code> through <code>r</code>, that they started in. The <code>merge</code> function creates two new temporary lists, <code>left</code> and <code>right</code>, copied from the original list. It then merges back into the original list. It repeatedly chooses the smaller of the unmerged items in <code>left</code> and <code>right</code> and copies it back into <code>the_list</code>. The index <code>i</code> always tells us the where to find the next unmerged item in <code>left</code>; <code>j</code> indexes the next unmerged item in <code>right</code>, and <code>k</code> indexes where the next merged item will go in <code>the_list</code>. Eventually, we exhaust either <code>left</code> or <code>right</code>. At that time, the other list still has unmerged items, and we can just copy them back into <code>the_list</code> directly.</p>
<p>Because the <code>merge</code> function spends a constant amount of time to fill each item in the sublist, it runs in time linear in the size of the sublist. That is, if the sublist <code>the_list[p : r+1]</code> contains <span class="math"><em>n</em></span> items, then <code>merge</code> runs in time <span class="math"><em>O</em>(<em>n</em>)</span>.</p>
<h3 id="sorting-recursively">Sorting recursively</h3>
<p>Recall that we saw the divide-and-conquer paradigm last time, and we also saw how merge sort uses it to sort a sublist <code>the_list[p : r+1]</code>:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Divide</strong> by finding the index <code>q</code> of the midpoint of the sublist <code>the_list[p : r+1]</code>.</p></li>
<li><p><strong>Conquer</strong> by recursing on the sublists <code>the_list[p : q+1]</code> and <code>the_list[q+1 : r+1]</code>. This step sorts the sublist <code>the_list[p : q+1]</code>, and it sorts the sublist <code>the_list[q+1 : r+1]</code>.</p></li>
<li><p><strong>Combine</strong> by merging the sorted sublist <code>the_list[p : q+1]</code> and <code>the_list[q+1 : r+1]</code> to produce the sorted sublist <code>thelist[p : r+1]</code>. We merge by calling the <code>merge</code> function.</p></li>
</ol>
<p>The recursion &quot;bottoms out&quot; when the sublist to be sorted has fewer than 2 items, since a sublist with 0 or 1 items is already sorted.</p>
<p>The <code>merge</code>_sort function shows how easy divide-and-conquer is for merge sort. It almost seems like cheating! But if you understand recursion, you'll believe that it works.</p>
<p>If you don't understand how the recursion works—I mean <em>really</em> understand it—I recommend that you</p>
<ul>
<li><p>use the debugging tool to step through the code,</p></li>
<li><p>draw the stack frames in the call stack as you step through the code by hand,</p></li>
<li><p>draw out the recursion tree for an example list, labeling each node by the values of the parameters <code>p</code> and <code>r</code> to <code>merge_sort</code>.</p></li>
</ul>
<h2 id="sorting-a-list-of-objects">Sorting a list of objects</h2>
<p>The merge sort function we saw is fine for sorting lists of items that can be easily compared, like strings or ints. What if we wanted to sort a list that contained addresses of (references to) objects? How does Python know which object is &quot;less than&quot; another?</p>
<p>If you are using the Python <code>.sort</code> method, it turns out that you can write a special method <code>__lt__</code> in the class definition. <code>__lt__</code> is then used to compare the objects when you use the less-than symbol &lt;.</p>
<p>But here, we're not using the Python <code>.sort</code> method. We're writing our own sorting code. How can we specify how we want to compare objects?</p>
<p>Imagine that you have a list of planets. You might wish to sort by mass, by distance from the sun, or by mean orbital velocity. These quantities might be stored in instance variables of a <code>Planet</code> object, or they might be computable using instance variables of a <code>Planet</code> object.</p>
<p>There is only one place in the merge sort code where we compare items from the list:</p>
<pre class="sourceCode"><code class="sourceCode python">        <span class="kw">if</span> left[i] &lt; right[l]:</code></pre>
<p>We need a function to replace the <code>&lt;</code>. Let's say we had two <code>Planet</code> objects, each with a <code>mass</code> instance variable. We could write the function like this:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> lessthan_mass(body1, body2):<br />    <span class="kw">return</span> body1.mass &lt; body2.mass</code></pre>
<p>I included &quot;mass&quot; in the function name to make it clear that this &quot;less than&quot; function compares masses. Somehow I need to specify to the merge sort code that <code>merge</code> should use the <code>lessthan_mass</code> function instead of a simple <code>&lt;</code> sign in comparisons. Fortunately, we can pass a function as a parameter to another function. We rewrite the header for <code>merge_sort</code> like this:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> merge_sort(the_list, p, r, compare_fn)</code></pre>
<p>and for <code>merge</code>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> merge(the_list, p, q, r, compare_fn):</code></pre>
<p>When <code>merge_sort</code> is called, we just pass in <code>lessthan_mass</code> (itself a function) as the second parameter. Within <code>merge_sort</code>, we change the call to <code>merge</code> to include <code>compare_fn</code> as the second actual parameter. Finally, in the body of <code>merge</code>, we can use <code>compare_fn</code> to compare items rather than using the <code>&lt;</code> sign:</p>
<pre class="sourceCode"><code class="sourceCode python">        <span class="kw">if</span> compare_fn(left[i], right[j]):</code></pre>
<h2 id="the-recursion-tree-for-merge-sort">The recursion tree for merge sort</h2>
<p>I find drawing the recursion tree to be one of the most helpful ways to understand or debug a recursive function. The recursion tree can be used to easily show:</p>
<ol style="list-style-type: decimal">
<li>What functions each function calls, and how the problem is broken into smaller problems.</li>
<li>The order functions are called in.</li>
<li>The base cases of the recursion, at the leaves.</li>
</ol>
<p>Here is the recursion tree for merge sort:</p>
<div class="figure">
<img src="merge_tree.png" /><p class="caption"></p>
</div>
<p>The calls to <code>merge</code> are in red. The order of the function calls is shown by small numbers above and to the left of each function call. We can also see the parameters of the functions. To save space, I abbreviated calls to <code>merge_sort</code> by <code>msort</code> and ommited the name of the list as a parameter.</p>
<p>You should be able to reconstruct the same tree by just reading and analyzing the code for merge sort, and you should be able to draw the recursion tree for any new recursive code you see or write.</p>
<h2 id="analyzing-runtime-for-recursive-function-calls">Analyzing runtime for recursive function calls</h2>
<p>The recursion tree is also often a very good way to analyze the running time of a recursive algorithm. In the following picture, I've used dashed lines to separate the recursion tree for a sample call to <code>merge_sort</code> into four layers.</p>
<div class="figure">
<img src="merge_runtime.png" /><p class="caption"></p>
</div>
<p>The top layer contains the initial call to <code>merge_sort</code> and its call to <code>merge</code>. The second layer contains the two merge sorts of half-size lists. The third layer contains the four merge sorts of quarter-size lists. The fourth layer contains the eight merge sorts of eighth-size lists.</p>
<p>Let's analyze the running time of each layer. A call to <code>merge_sort</code> has two types of costs:</p>
<ol style="list-style-type: decimal">
<li>The cost associated with all lines of code except function calls to <code>merge</code> or <code>merge_sort</code>. Let's call this a constant, <span class="math"><em>c</em></span>.</li>
<li>The cost associated with calls to <code>merge</code> and <code>merge_sort</code>.</li>
</ol>
<p>When we account for the runing time, we'll charge the second types of cost to the functions where the work is actually done. For example, when we compute the cost of the top layer, we won't include the costs incurred by layer 2.</p>
<ul>
<li><p><strong>Layer 1 (top layer).</strong> There is one call to <code>merge_sort</code>. The charge for that is <span class="math"><em>c</em></span>. There is one call to <code>merge</code>. If we analyze the running time of <code>merge</code>, the cost is some constant, <span class="math"><em>k</em></span>, times the length of the sublist. So <code>merge(0, 7)</code> costs <span class="math">8<em>k</em></span> time, or <span class="math"><em>n</em><em>k</em></span> time. The overall cost of the layer is <span class="math">1 × (<em>c</em> + <em>n</em><em>k</em>)</span>.</p></li>
<li><p><strong>Layer 2.</strong> There are two calls to <code>merge_sort</code>. The charge for that is <span class="math">2<em>c</em></span>. There are two calls to <code>merge</code>. The charges are each <span class="math"><em>n</em> / 2 × <em>k</em></span>, for a total &quot;merging charge&quot; of <span class="math"><em>n</em><em>k</em></span>. The overall cost of the layer is <span class="math">2<em>c</em> + <em>n</em><em>k</em></span>.</p></li>
<li><p><strong>Layer 3.</strong> Four calls to <code>merge_sort</code>: <span class="math">4<em>c</em></span>. Four calls to <code>merge</code>, each of size <span class="math"><em>n</em> / 4</span>, giving a cost of <span class="math"><em>n</em><em>k</em></span>. Total cost: <span class="math">4<em>c</em> + <em>n</em><em>k</em></span>.</p></li>
<li><p><strong>Layer 4.</strong> Eight calls to <code>merge_sort</code>s: <span class="math">8<em>c</em></span>. No merges. Total cost: <span class="math"><em>n</em><em>c</em></span>.</p></li>
</ul>
<p>Overall, we see that, not counting the cost of merging, the <span class="math">2<em>n</em> - 1</span> calls to <code>merge_sort</code> cost <span class="math">(2<em>n</em> - 1)<em>c</em></span> time. Now let's look at the <code>merge</code> costs. Each layer of the tree costs the same for the <code>merges</code>: later layers of the tree had more merges, but the merges were smaller. Layers 1, 2, and 3 cost <span class="math"><em>n</em><em>k</em></span> each. How many layers is the tree? Since we divide the sublist in half for each new layer, there are <span class="math">1 + log<sub>2</sub><em>n</em></span> layers in the tree. The last layer doesn't have a merge, and so the total merge cost is <span class="math"><em>n</em><em>k</em>(log<sub>2</sub><em>n</em>)</span>.</p>
<p>Our total cost for merge sort is therefore <span class="math">(2<em>n</em> - 1)<em>c</em> + (log<sub>2</sub><em>n</em>)<em>n</em><em>k</em></span>. We see that the fastest growing term is <span class="math"><em>n</em><em>k</em> log<sub>2</sub><em>n</em></span>; dropping the constants, we get that the running time of merge sort is <span class="math"><em>O</em>(<em>n</em> log<sub>2</sub><em>n</em>)</span>. When the base of the logarithm is a constant, such as 2, we can drop that, too: <span class="math"><em>O</em>(<em>n</em> log <em>n</em>)</span>.</p>
<h1 id="linked-lists">Linked lists</h1>
<p>For the next few weeks, we will be looking at how to implement and use different types of <strong>data structures</strong>. We have already seen an example of a data structure: a Python list. In general, data structures:</p>
<ol style="list-style-type: decimal">
<li><p>provide a place to efficiently store and retrieve items of information;</p></li>
<li><p>express some relationship between items; and</p></li>
<li><p>allow algorithms to find, reorder, or apply operations to items in the data structure, using the implied relationship between the items.</p></li>
</ol>
<p>Does the Python list provide a place to store and retrieve items? Yes; for example, we might have a list of numbers, strings, or address of <code>Body</code> objects. What relationship can the list express between items? The items are in some <em>order</em> implied by the indices of items in the list. For example, we say that the fourth item follows the third item in the list, and it precedes the fifth item. We have seen algorithms that reorder the list (changing the relationship between items), find items in the list, or just apply operations to each item in the list (for example, compute the acclerations and velocities of all planets in a list of planets).</p>
<p><strong>Linked lists</strong> are a type of data structure that you have not seen yet in this course. Unlike Python lists, linked lists are not built in to Python, and we will have to implement them ourselves.</p>
<p>Linked lists provide many of the same features that Python lists do:</p>
<ol style="list-style-type: decimal">
<li>Linked lists contain an ordered sequence of items.</li>
<li>You can append, insert, or delete items from a linked list.</li>
<li>You can traverse a linked list, applying a function to each time in the list in order.</li>
</ol>
<p>For many purposes, Python lists are a good choice for containing several items in sequential order. Because Python lists are built in to the language, they have been optimized for speed, and the time costs for accessing, deleting, changing, or adding an item have small constant factors associated with them. Since we will write our own linked lists, Python has to interpret the code we write, which will take some time. Nevertheless, for sufficiently large numbers of items, linked lists may provide some advantages for some operations.</p>
<h2 id="time-costs-of-operations-on-python-lists">Time costs of operations on Python lists</h2>
<p>Let's look at how Python lists actually work. Earlier in the course, I expressed concern about how list operations are actually implemented. Here's how Python implements lists. The items in a Python list are stored in order in memory. Consider a list of 4-byte integers. The 0th item in the list is stored at some address, let's say 7080. Then the first item would be stored at 7084. The second item would be at 7088, and so on. The <span class="math"><em>i</em></span>th item would be at address <span class="math">7088 + 4<em>i</em></span>.</p>
<h3 id="runing-time-of-inserting-an-item-into-a-python-list">Runing time of inserting an item into a Python list</h3>
<p>Let's say you have a Python list with 20 items. You would like to maintain the order of the items, and you would like to insert a new item as the first item of the list. You can do this with the <code>insert</code> method of lists, like this:</p>
<pre class="sourceCode"><code class="sourceCode python">l = [<span class="dv">10</span>, <span class="dv">14</span>, <span class="dv">16</span>, <span class="dv">22</span>]<br />l.insert(<span class="dv">0</span>, <span class="dv">999</span>)</code></pre>
<p>The new item will be at index 0. Notice that the item previously at index 0 has to move to index 1, the item previously at index 1 has to move to index 2, and so forth. With some cleverness, you might realize that the best way to do this operation would be to start at the end of the list and move each item one position to the right (does this idea remind you of insertion sort?), but no amount of cleverness will save you from having to loop over each item in the list and moving it.</p>
<p>Inserting into the beginning of the list is the worst case, since all other items have to be moved to the right; inserting at the end of the list is much cheaper. So the worst case running time for insertion into an <span class="math"><em>n</em></span>-item Python list is <span class="math"><em>O</em>(<em>n</em>)</span>.</p>
<h3 id="time-cost-of-appending-to-a-list-amortized-running-time">Time cost of appending to a list: amortized running time</h3>
<p>You might think that appending to the list (inserting at the end) would have run time <span class="math"><em>O</em>(1)</span> since items do not have to be copied. As one of my favorite faux titles for a country song goes, &quot;Purt near but not plumb.&quot; That is, it's <em>almost</em> true. Here's why it is not entirely true. The list is stored in one sequential area of memory. What happens if you try to make the list longer, and there is something stored in memory just after the list? In this case, Python requests a new, larger amount of memory; the computer finds a new location, and relocates the list to that new location by <em>copying</em> the entire list. If the list has <span class="math"><em>n</em></span> items, then copying the list takes <span class="math"><em>O</em>(<em>n</em>)</span> time, and so in the worst case (the situation where the list has to be moved), appending to the list takes <span class="math"><em>O</em>(<em>n</em>)</span> time. That is, of course, a lot worse than the <span class="math"><em>O</em>(1)</span> time that you might have expected.</p>
<p>But the designers of Python used a very clever idea to make sure that this worst case running time for appending to a list occurs infrequently. We've seen that when Python appends to an existing list and runs out of space, it has to request a new chunk of memory, where it will move the list. Let's say the list length is <span class="math"><em>n</em></span>. But instead of requesting enough space for a list of size <span class="math"><em>n</em> + 1</span>, Python arranges to have room for the new list to grow, and it requests space for a list of size <span class="math">2<em>n</em></span>. Overallocating in this way might seem as though it wastes a lot of space—Python allocates up to twice the amount of memory that the list really needs. But the advantage is that if you append items to the list over and over again, the list is moved infrequently.</p>
<p>Let's say you add 128 items to a list in order, starting with a list of size 1. As you append items to the list, Python will increase the memory allocated to the list. At first, there is memory for 1 item. Then for 2 items. When that space fills up, Python allocates a list with space for 4 items. When that fills up, space for 8. Then 16, 32, 64, and finally, 128. Let's see what happens as we increase the list size from 64 to 129.</p>
<p>Imagine that it costs 1 dollar to append an item to a list if Python does <em>not</em> have to reallocate space and copy all the items, and that it costs 1 dollar to copy an item when the list is copied to a new location. When we append an item to the list, let's charge not 1 dollar, but 3 dollars. Of the 3 dollars, we'll use 1 dollar to pay for the append operation, and we'll keep the other 2 dollars in a bank account for the item; we'll spend this 2 dollars later.</p>
<p>Our list has 64 items, and now let's append another 64 items. We're charged <span class="math">64 × 3</span> dollars for these append operations, with 64 dollars going toward paying for the appends and the remaining 128 dollars in the bank. Now we add the 129th item. Before appending this item, we have to copy all 128 of the previous items into reallocated space. But we have 128 dollars already in the bank to pay for it! So we spend the 128 dollars to copy the 128 items, and then we can append the 129th item, paying 1 dollar for the append operation and banking the other 2 dollars.</p>
<p>The key idea here is that the list size doubles. Each item pays 1 dollar for its own append, 1 dollar for itself to be copied one time, and 1 dollar for a previously appended item to be copied one time. Since we pay a constant amount, 3 dollars, for each item we can think of the average time per append being constant, or <span class="math"><em>O</em>(1)</span>.</p>
<p>We call this sort of analysis an <strong>amortized running time</strong> analysis, because the possibly expensive cost of adding one item to the list is offset by frequently adding items to the end of the list cheaply. We can &quot;amortize&quot; the cost over several append operations, and show that the behavior of the append operation is pretty good over the long run.</p>
<h3 id="time-cost-of-deleting-an-item-from-a-list">Time cost of deleting an item from a list</h3>
<p>If you would like to maintain the order of the list and also delete an item, then the worst-case cost for an <span class="math"><em>n</em></span>-item list is <span class="math"><em>O</em>(<em>n</em>)</span>, since all items following the deleted item have to be moved up by one position in the list. You can delete items from a list using the special built-in operator <code>del</code> in Python:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">del</span> l[<span class="dv">3</span>]</code></pre>
<p>Deleting from the end is a special case that is not expensive, since no items in the list have to be moved; deleting from the end has time cost <span class="math"><em>O</em>(1)</span>. We call deleting from the end <strong>popping</strong>, and there is a special <code>pop</code> method on lists that removes from the end, returning the item that was removed.</p>
<h3 id="time-cost-of-finding-an-item-in-a-list">Time cost of finding an item in a list</h3>
<p>If the list is unsorted, then it takes <span class="math"><em>O</em>(<em>n</em>)</span> time to find the item in an <span class="math"><em>n</em></span>-item list, by using linear search. Similarly, finding the smallest or largest item in an unsorted list takes <span class="math"><em>O</em>(<em>n</em>)</span> time.</p>
<h3 id="tricks-unordered-lists-sets">Tricks: Unordered lists (sets)</h3>
<p>A list maintains items in order. But sometimes you do not care about the order of items in the list. You can use this observation to sometimes insert or remove items without occuring an <span class="math"><em>O</em>(<em>n</em>)</span> running time. If the order doesn't matter, just insert by appending. When you delete an item from the list, instead of shifting all the items that follow the deleted item, you can fill the hole left by the deleted item by moving in the item that's at the of the list. In Python, however, you should probably more properly use the built-in <code>set</code> data structure to store items for which you do not care about the order. We will not discuss the <code>set</code> data structure further at this time, but you are welcome to look it up in the Python documentation.</p>
<h2 id="linked-lists-1">Linked lists</h2>
<p>Linked lists, like Python lists, contain items in some order, but the implementation of linked lists will be very different from that of Python lists. There are two reasons we will implement our own linked lists:</p>
<ol style="list-style-type: decimal">
<li><p>Certain operations for linked lists are efficient in terms of time. For example, inserting an item after another item in the middle of the list costs <span class="math"><em>O</em>(1)</span> time—much better than the <span class="math"><em>O</em>(<em>n</em>)</span> time for inserting into an <span class="math"><em>n</em></span>-item Python list. For large enough linked lists, in a situation where insertion in the middle is frequent, a linked list might be the better choice, despite the smaller constant factor for Python lists.</p></li>
<li><p>The approach we will use to create the linked list is an example that we will build on to form more complex data structures, trees and graphs, that express more interesting relationships between data than the simple sequential list structure.</p></li>
</ol>
<h2 id="nodes-in-the-list">Nodes in the list</h2>
<p>Conceptually, we will create a linked list by making lots of objects called <strong>nodes</strong>. Each <code>Node</code> object will contain an item: the data in the list. The <code>Node</code> objects themselves could be anywhere in memory, and will typically <em>not</em> be stored sequentially, or in any other particular order, in memory.</p>
<p>How, then, can we tell which item in the list is first, which is second, and what the order of items is? Each <code>Node</code> object will contain an instance variable that has the address of the next <code>Node</code> object in the linked list.</p>
<p>Let's look at an example of how this might work. (I should emphasize that this is not yet a good implementation of a linked list. I just want to show you how nodes work.) Here's a picture of a linked list holding the names of three states, in order: Maine, Idaho, and Utah:</p>
<div class="figure">
<img src="states-SLL.png" /><p class="caption"></p>
</div>
<p>The arrows indicate references. The slash in the <code>next</code> instance variable of the last <code>Node</code> object (the one whose data is <code>Utah</code>) is how I indicate the value <code>None</code> in a picture.</p>
<p>Here's some simple code, in <a href="node_example.py">node_example.py</a>. Although we usually put a class in its own file, I didn't put the <code>Node</code> class in its own node.py file because I wanted to keep this example short and in one place.</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># node_example.py</span><br /><span class="co"># CS 1 class example by Devin Balkcom, modified by THC.</span><br /><span class="co"># Shows a simple way to use Node objects to form a linked list.</span><br /><br /><span class="kw">class</span> Node:<br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, data):<br />        <span class="ot">self</span>.data = data  <span class="co"># instance variable to store the data</span><br />        <span class="ot">self</span>.<span class="dt">next</span> = <span class="ot">None</span>  <span class="co"># instance variable with address of next node</span><br /><br /><span class="co"># The head is the first node in a linked list.</span><br />head = Node(<span class="st">&quot;Maine&quot;</span>)<br /><br /><span class="co"># Create a new node.</span><br />another_node = Node(<span class="st">&quot;Idaho&quot;</span>)<br /><br /><span class="co"># Store the address of the Idaho node as the</span><br /><span class="co">#  next address of the first node in the list.</span><br />head.<span class="dt">next</span> = another_node<br /><br /><span class="co"># Create a third node.</span><br />a_third_node = Node(<span class="st">&quot;Utah&quot;</span>)<br /><br /><span class="co"># Link the second node to the third node.</span><br />another_node.<span class="dt">next</span> = a_third_node<br /><br /><span class="co"># An example of printing the data of the list in order:</span><br />node = head   <span class="co"># copy the address of the head node into node</span><br /><span class="kw">while</span> node != <span class="ot">None</span>:<br />    <span class="kw">print</span> node.data<br />    node = node.<span class="dt">next</span></code></pre>
<p>When we printed the list, we created a new, temporary variable <code>node</code> that initially has the address of the first <code>Node</code> object in the linked list. We use that address to find the data to print (<code>Maine</code>), and then we update <code>node</code> to hold the address of the next item. We print its data (<code>Idaho</code>) and update <code>node</code> again to hold the address of the next item. We print its data (<code>Utah</code>), and update <code>node</code> once again. Now, <code>node</code> equals <code>None</code>, and we drop out of the while-loop.</p>
<h2 id="circular-doubly-linked-list-with-a-sentinel">Circular, doubly linked list with a sentinel</h2>
<p>We did some things manually in the above example. It would be nice to have a class for a linked list that stored the address of the first node, and that also provided methods for inserting into, deleting from, appending to, and finding items in the list.</p>
<p>Our previous model for a linked list, in which only the address of the next node is stored in any node, has some annoying special cases. We will therefore start with a slightly different implementation that has a few convenient features that at first blush might seem more complicated, but actually simplify the implementation of certain methods, and even improve the running time of certain methods.</p>
<ol style="list-style-type: decimal">
<li><p>The list will be <strong>doubly linked</strong>: each node will contain a reference to the <em>previous</em> node in the chain (in a <code>prev</code> instance variable) as well as a reference to the <em>next</em> node. Although this structure makes it easy to iterate backward through the list, it makes other, more common, operation easy, too.</p></li>
<li><p>The list will have a <strong>sentinel</strong> node, instead of a reference to a first node. This sentinel node is a special node that acts as the 0th node in the linked list. No data is stored in this special node; it's there just as a placeholder in the list.</p></li>
<li><p>The list will be <strong>circular</strong>. The last node containing data will hold in its <code>next</code> instance variable the address of the sentinel node, and the sentinel node's <code>prev</code> instance variable will hold the address of the last node.</p></li>
</ol>
<p>We call this structure a <strong>circular, doubly linked list with a sentinel</strong>. Quite a mouthful, indeed. Practice saying it fast.</p>
<p>A circular, doubly linked list with a sentinel has the property that <em>every</em> node references a next node and a previous node. Always. This uniform way of treating nodes turns out to be quite convenient, because as we write methods to insert or delete nodes into the list, we don't have to worry about special cases that would arise if the last node didn't have a next node, and the first node didn't have a previous node, but all interior nodes had both.</p>
<p>Here is a picture of a circular, doubly linked list with a sentinel representing the same list as before:</p>
<div class="figure">
<img src="states-DLL.png" /><p class="caption"></p>
</div>
<p>We create a class, <code>Sentinel_DLL</code>, to implement a circular, doubly linked list with sentinel in <a href="sentinel_DLL.py">sentinel_DLL.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># sentinel_DLL.py</span><br /><span class="co"># CS 1 class example for a circular, doubly linked list with a sentinel.</span><br /><span class="co"># Written by Devin Balkcom, modified by THC.</span><br /><br /><span class="co"># Class for a node in a circular, doubly linked list with a sentinel.</span><br /><span class="kw">class</span> Node:<br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, data):<br />        <span class="ot">self</span>.data = data  <span class="co"># instance variable to store the data</span><br />        <span class="ot">self</span>.<span class="dt">next</span> = <span class="ot">None</span>  <span class="co"># instance variable with address of next node</span><br />        <span class="ot">self</span>.prev = <span class="ot">None</span>  <span class="co"># instance variable with address of previous node</span><br /><br /><span class="co"># Class for a circular, doubly linked list with a sentinel.</span><br /><span class="kw">class</span> Sentinel_DLL:<br />    <span class="co"># Create the sentinel node, which is before the first node</span><br />    <span class="co"># and after the last node.</span><br />    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>):        <br />        <span class="ot">self</span>.sentinel = Node(<span class="ot">None</span>)<br />        <span class="ot">self</span>.sentinel.<span class="dt">next</span> = <span class="ot">self</span>.sentinel<br />        <span class="ot">self</span>.sentinel.prev = <span class="ot">self</span>.sentinel<br /><br />    <span class="co"># Return a reference to the first node in the list, if there is one.</span><br />    <span class="co"># If the list is empty, return None.</span><br />    <span class="kw">def</span> first_node(<span class="ot">self</span>):<br />        <span class="kw">if</span> <span class="ot">self</span>.sentinel.<span class="dt">next</span> == <span class="ot">self</span>.sentinel:<br />            <span class="kw">return</span> <span class="ot">None</span><br />        <span class="kw">else</span>:<br />            <span class="kw">return</span> <span class="ot">self</span>.sentinel.<span class="dt">next</span><br /><br />    <span class="co"># Insert a new node with data after node x.</span><br />    <span class="kw">def</span> insert_after(<span class="ot">self</span>, x, data):<br />        y = Node(data)   <span class="co"># make a new Node object.</span><br /><br />        <span class="co"># Fix up the links in the new node.</span><br />        y.prev = x<br />        y.<span class="dt">next</span> = x.<span class="dt">next</span><br /><br />        <span class="co"># The new node follows x.</span><br />        x.<span class="dt">next</span> = y<br /><br />        <span class="co"># And it's the previous node of its next node.</span><br />        y.<span class="dt">next</span>.prev = y<br /><br />    <span class="co"># Insert a new node at the end of the list.    </span><br />    <span class="kw">def</span> append(<span class="ot">self</span>, data):<br />        last_node = <span class="ot">self</span>.sentinel.prev<br />        <span class="ot">self</span>.insert_after(last_node, data)<br /><br />    <span class="co"># Delete node x from the list.</span><br />    <span class="kw">def</span> delete(<span class="ot">self</span>, x):<br />        <span class="co"># Splice out node x by making its next and previous</span><br />        <span class="co"># reference each other.</span><br />        x.prev.<span class="dt">next</span> = x.<span class="dt">next</span><br />        x.<span class="dt">next</span>.prev = x.prev<br /><br />    <span class="co"># Find a node containing data, and return a reference to it.</span><br />    <span class="co"># If no node contains data, return None.</span><br />    <span class="kw">def</span> find(<span class="ot">self</span>, data):<br />        <span class="co"># Trick: Store a copy of the data in the sentinel,</span><br />        <span class="co"># so that the data is always found.  </span><br />        <span class="ot">self</span>.sentinel.data = data<br /><br />        x = <span class="ot">self</span>.first_node()<br />        <span class="kw">while</span> x.data != data:<br />            x = x.<span class="dt">next</span><br /><br />        <span class="co"># Restore the sentinel's data.</span><br />        <span class="ot">self</span>.sentinel.data = <span class="ot">None</span><br /><br />        <span class="co"># Why did we drop out of the while-loop?</span><br />        <span class="co"># If we found the data in the sentinel, then it wasn't</span><br />        <span class="co"># anywhere else in the list.</span><br />        <span class="kw">if</span> x == <span class="ot">self</span>.sentinel:<br />            <span class="kw">return</span> <span class="ot">None</span>     <span class="co"># data wasn't really in the list</span><br />        <span class="kw">else</span>:<br />            <span class="kw">return</span> x        <span class="co"># we found it in x, in the list</span><br /><br /><br />    <span class="co"># Return the string representation of a circular, doubly linked</span><br />    <span class="co"># list with a sentinel, just as if it were a Python list.</span><br />    <span class="kw">def</span> <span class="ot">__str__</span>(<span class="ot">self</span>):<br />        s = <span class="st">&quot;[&quot;</span><br /><br />        x = <span class="ot">self</span>.sentinel.<span class="dt">next</span><br />        <span class="kw">while</span> x != <span class="ot">self</span>.sentinel: <span class="co"># look at each node in the list</span><br />            <span class="kw">if</span> <span class="dt">type</span>(x.data) == <span class="dt">str</span>:<br />                s += <span class="st">&quot;'&quot;</span><br />            s += <span class="dt">str</span>(x.data)        <span class="co"># concatenate this node's data to the string</span><br />            <span class="kw">if</span> <span class="dt">type</span>(x.data) == <span class="dt">str</span>:<br />                s += <span class="st">&quot;'&quot;</span><br />            <span class="kw">if</span> x.<span class="dt">next</span> != <span class="ot">self</span>.sentinel:<br />                s += <span class="st">&quot;, &quot;</span>   <span class="co"># if not the last node, add the comma and space</span><br />            x = x.<span class="dt">next</span><br /><br />        s += <span class="st">&quot;]&quot;</span>        <br />        <span class="kw">return</span> s</code></pre>
<h3 id="creating-an-empty-list-__init__">Creating an empty list: <code>__init__</code></h3>
<p>A <code>Sentinel_DLL</code> object has just one instance variable: <code>sentinel</code>. This instance variable is a reference to a <code>Node</code> object. I defined the <code>Node</code> class in the sentinel_DLL.py file, rather than defining it in its own file, because it's meant only to be part of a circular, doubly linked list with a sentinel.</p>
<p>In order for the list to be circular, both the <code>next</code> and <code>prev</code> instance variables of the sentinel node must contain the address of the sentinel itself. Here's what an empty list looks like:</p>
<div class="figure">
<img src="empty-DLL.png" /><p class="caption"></p>
</div>
<p>It can at first be intimidating to see a line with as many dot operators in it as</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="ot">self</span>.sentinel.<span class="dt">next</span> = <span class="ot">self</span>.sentinel</code></pre>
<p>Just work left to right for each variable. <code>self</code> is the address of a <code>sentinel_DLL</code> object. <code>self.sentinel</code> is the value of the <code>sentinel</code> instance variable in the <code>sentinel_DLL</code> object. We know that that value contains the address of some <code>Node</code> object. So <code>self.sentinel.next</code> is the <code>next</code> instance variable of the sentinel node in the <code>sentinel_DLL</code> object. That's what we're assigning <em>to</em>. The value we're assigning is <code>self.sentinel</code>, the address of the sentinel node.</p>
<h3 id="finding-the-first-node">Finding the first node</h3>
<p>The <code>first_node</code> method just returns a reference to the first node in the list, or <code>None</code> if the list contains just the sentinel. The first node is always the one after the sentinel. If the node just after the sentinel is the sentinel itself, then the list contains just the sentinel, and the method returns <code>None</code>. Otherwise, the method returns a reference to the first node.</p>
<h3 id="inserting-a-new-node-into-a-list">Inserting a new node into a list</h3>
<p>To insert a new node into the list, we need to know which node we're inserting it after. The parameter <code>x</code> is a reference to that node. The parameter <code>data</code> gives the data that we're inserting.</p>
<p>First, the method creates a new <code>Node</code> object, referenced by <code>y</code>, to hold the data that we want to add to the list. Now we need to &quot;splice&quot; the new node into the list, just as you can splice a new section into a piece of rope or magnetic tape. In order to splice in the new node, we need to do a few things:</p>
<ol style="list-style-type: decimal">
<li><p>Make the links in the new node refer to the previous and next nodes in the list.</p></li>
<li><p>Make the <code>next</code> link from the node that will precede the new node refer to the new node.</p></li>
<li><p>Make the <code>prev</code> link from the node that will follow the new node refer to the new node.</p></li>
</ol>
<p>We have to be a little careful about the order in which we do these operations. Let's name the nodes for convenience. We already have <code>x</code> referencing the node that the new node, referenced by <code>y</code>, goes after. Let <code>z</code> reference the next node after <code>x</code> <em>before</em> we insert <code>y</code>, so that <code>y</code> is supposed to go between <code>x</code> and <code>z</code>. If we clobber the value of the <code>next</code> instance variable of <code>x</code> too soon, we won't have a way to get the address of <code>z</code>, which we will need.</p>
<p>It's good to be comfortable with the dot notation used so heavily in the code, but it may help you to draw a picture. Here's the same method as above, but with a temporary variable introduced for <code>z</code>:</p>
<pre class="sourceCode"><code class="sourceCode python">    <span class="co"># Insert a new node with data after node x.</span><br />    <span class="kw">def</span> insert_after(<span class="ot">self</span>, x, data):<br />        y = Node(data)   <span class="co"># make a new Node object.</span><br />        z = x.<span class="dt">next</span>       <span class="co"># y goes between x and z</span><br /><br />        <span class="co"># Fix up the links in the new node.</span><br />        y.prev = x<br />        y.<span class="dt">next</span> = z<br /><br />        <span class="co"># The new node follows x.</span><br />        x.<span class="dt">next</span> = y<br /><br />        <span class="co"># And it's the previous node of z.</span><br />        z.prev = y</code></pre>
<h3 id="iterating-over-a-list">Iterating over a list</h3>
<p>The <code>__str__</code> method shows an example of how to iterate over a list. The first node in the list is the node after the sentinel. We loop over nodes, letting <code>x</code> reference each node in the list, until returning to the sentinel again (recall that the list is circular). To get to the next node in the list, we use the line <code>x = x.next</code>.</p>
<p>One other interesting thing about the <code>__str__</code> method is that I wrote it to produce the same string as you'd see if the linked list were a regular Python list. When Python prints a list, it puts single quotes around all strings in the list. So I have a check to see whether <code>x.data</code> is a string, and if it is, I add in the single quotes.</p>
<h3 id="deleting-from-a-list">Deleting from a list</h3>
<p>The <code>delete</code> method takes a node <code>x</code> and deletes it from the list. It's deceptively simple in how it splices the node out, by just making its next and previous nodes reference each other. Just we did for insertion, let's rewrite the <code>delete</code> method, but with <code>y</code> referencing <code>x</code>'s previous node and <code>z</code> referencing <code>x</code>'s next node:</p>
<pre class="sourceCode"><code class="sourceCode python">    <span class="co"># Delete node x from the list.</span><br />    <span class="kw">def</span> delete(<span class="ot">self</span>, x):<br />        <span class="co"># Splice out node x by making its next and previous</span><br />        <span class="co"># reference each other.</span><br />        y = x.prev<br />        z = x.<span class="dt">next</span><br />        y.<span class="dt">next</span> = z<br />        z.prev = y</code></pre>
<h3 id="searching-a-list">Searching a list</h3>
<p>The <code>find</code> method searches the linked list for a node with a given data value, returning a reference to the first node that has the value, or <code>None</code> if no nodes have the value. It uses linear search, but in a linked list.</p>
<p>There's a cute trick that I've incorporated into my implementation of <code>find</code>. If you go back to the <a href="../lecture13/linear_search.py">linear search code</a> that we saw before, you'll notice that each loop iteration makes two tests: one to check that we haven't reached the end of the list and one to see whether the list item matches what we're searching for:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="kw">def</span> linear_search(the_list, key):<br />    index = <span class="dv">0</span><br />    <span class="kw">while</span> index &lt; <span class="dt">len</span>(the_list):<br />        <span class="kw">if</span> key == the_list[index]:<br />            <span class="kw">return</span> index<br />        <span class="kw">else</span>:<br />            index += <span class="dv">1</span><br /><br />    <span class="kw">return</span> <span class="ot">None</span></code></pre>
<p>Suppose that you <em>knew</em> you'd find the item in the list. Then you wouldn't have to check for reaching the end of the list, right? So let's put the value we're looking for into the linked list, but in a special place that tells us if that's where we find it, then the only reason we found it was because we looked everywhere else before finding it in that special place.</p>
<p>Gosh, if only we had an extra node in the list that didn't contain any data and was at the end of the list. We do: the sentinel. So we put the value we're looking for in the sentinel's <code>data</code> instance variable, start at the first node after the sentinel, and loop until we see a match. If the match was <em>not</em> in the sentinel, then we found the value in the list. If the match <em>was</em> in the sentinel, the the value wasn't really in the list; we found it only because we got all the way back to the sentinel. In either case, we put <code>None</code> back into the sentinel's <code>data</code> instance variable because, well, my mother told me to.</p>
<h3 id="appending-to-the-list">Appending to the list</h3>
<p>The only other method in my <code>Sentinel_DLL</code> class is <code>append</code>. Not surprisingly, it finds the last node in the list and then calls <code>insert_after</code> for that node. How to find the last node in the list? It's just the sentinel's previous node.</p>
<h3 id="running-times-of-the-linked-list-operations">Running times of the linked-list operations</h3>
<p>What are the worst-case running times of the operations for a circular, doubly linked list with a sentinel? Let's assume that the list has <span class="math"><em>n</em></span> items (<span class="math"><em>n</em> + 1</span> nodes, including the sentinel, but of course the <span class="math"> + 1</span> won't matter when we use big-Oh notation).</p>
<p>The <code>__init__</code>, <code>first_node</code>, <code>insert_after</code>, <code>append</code>, and <code>delete</code> methods each take <span class="math"><em>O</em>(1)</span> time, since they each look at only a constant number of nodes.</p>
<p>The <code>__str__</code> method takes <span class="math"><em>O</em>(<em>n</em>)</span> time, since it has to visit every node once.</p>
<p>The time taken by the <code>find</code> method depends on how far down the linked list it has to go. In the worst case, the value is not present, and <code>find</code> has to examine every node once, for a worst-case running time of <span class="math"><em>O</em>(<em>n</em>)</span>.</p>
<h3 id="testing-the-linked-list-operations">Testing the linked list operations</h3>
<p>You can test the linked list operations by writing your own driver. I have a pretty minimal driver in <a href="test_sentinel_DLL.py">test_sentinel_DLL.py</a>:</p>
<pre class="sourceCode"><code class="sourceCode python"><span class="co"># test_sentinel_DLL.py</span><br /><span class="co"># CS 1 class example by THC.</span><br /><span class="co"># Tests the Sentinel_DLL class.</span><br /><br /><span class="ch">from</span> sentinel_DLL <span class="ch">import</span> Sentinel_DLL<br /><br /><span class="kw">def</span> test_sentinel_DLL():<br />    <span class="co"># Make a linked list with Maine, Idaho, and Utah.</span><br />    l = Sentinel_DLL()<br />    l.append(<span class="st">&quot;Maine&quot;</span>)<br />    l.append(<span class="st">&quot;Idaho&quot;</span>)<br />    l.append(<span class="st">&quot;Utah&quot;</span>)<br /><br />    <span class="co"># Add Ohio after Idaho.</span><br />    node = l.find(<span class="st">&quot;Idaho&quot;</span>)<br />    <span class="kw">if</span> node != <span class="ot">None</span>:<br />        <span class="kw">print</span> node.data<br />        l.insert_after(node, <span class="st">&quot;Ohio&quot;</span>)<br />    <span class="kw">print</span> l<br /><br />    <span class="co"># Delete Idaho.</span><br />    <span class="kw">if</span> node != <span class="ot">None</span>:<br />        l.delete(node)<br />    <span class="kw">print</span> l<br /><br />    <span class="co"># Empty out the list, one node at a time.</span><br />    <span class="kw">while</span> l.first_node() != <span class="ot">None</span>:<br />        l.delete(l.first_node())<br /><br />    <span class="kw">print</span> l<br /><br />test_sentinel_DLL()</code></pre>
</body>
</html>
